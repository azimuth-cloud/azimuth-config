# Terraform state

`azimuth-ops` uses [Terraform](https://www.terraform.io/) to manage the K3S node in both the
single node and high-availability deployment deployment methods.

In order to keep track of the resources that it has created, and how they map to the resources
in the Terraform configuration generated by `azimuth-ops`, Terraform must
[store its state](https://www.terraform.io/language/state) somewhere. The location of the
state is determined by the
[backend configuration](https://www.terraform.io/language/settings/backends/configuration).

Each environment in an `azimuth-config` repository has a corresponding Terraform state, and
they are independent from each other.

## Local state

By default `azimuth-ops` will use the `local` backend, which stores the Terraform state as
a file on the local disk in the `.work` directory. This requires no explicit configuration,
but comes with the usual caveats about keeping important state on your local machine.

!!! danger  "Not suitable for production"

    Local state is sufficient for a demonstration or evaluation, but for a shared or
    production deployment it is recommended to use remote state.

## Remote state

Terraform supports a number of remote backends that can be used to persist Terraform state
independently of where a deployment is run. This allows deployments to be made from anywhere
that can access the state without corrupting or conflicting with any existing resources
from previous deployments.

!!! warning

    In order to avoid multiple writers when using remote state, it is recommended to use
    a backend that supports
    [state locking](https://www.terraform.io/language/state/locking).

!!! tip

    Configuration of the Terraform backend is done using Linux environment variables, using
    [env files in azimuth-config environments](../environments.md#linux-environment-variables).

The `azimuth-ops` and `azimuth-config` tooling currently only support a subset of the
available Terraform backends. The following backends are currently supported:

### HTTP

The [HTTP backend](https://www.terraform.io/language/settings/backends/http) is a simple
REST client that uses `GET`, `POST` and `DELETE` HTTP requests to manage a Terraform
state. State locking is optional, but it is recommended to use an implementation that
supports it.

To use the HTTP backend, you must set *at least* the following environment variables:

```sh  title="env"
# Tell azimuth-ops to use the HTTP backend
AZIMUTH_TERRAFORM_BACKEND_TYPE=http

# The state endpoint for the environment
# Using the AZIMUTH_ENVIRONMENT variable means this is different for each environment
# without needing environment-specific variables
TF_HTTP_ADDRESS="https://example.org/tfstate/${AZIMUTH_ENVIRONMENT}"
```

For the full set of available environment variables, see the Terraform docs.

#### GitLab

!!! tip

    This is the recommended option if you are using [GitLab](https://about.gitlab.com/)
    for your config repository.

If you are using GitLab to host your configuration repository, either `gitlab.com` or
self-hosted, you can use
[GitLab-managed Terraform state](https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html)
to store the Terraform state for your environments.

GitLab provides a HTTP backend that can be configured by putting the following into your
the `env` file for your repository:

```sh  title="env"
# Use the http backend type
AZIMUTH_TERRAFORM_BACKEND_TYPE=http

# The API base URL for the target GitLab project
#   For a self-hosted GitLab instance, replace gitlab.com with your domain
GITLAB_PROJECT_URL="https://gitlab.com/api/v4/projects/<project id>"

# The state endpoint for the environment
TF_HTTP_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_ENVIRONMENT}"

# The state-locking endpoint for the environment
TF_HTTP_LOCK_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_ENVIRONMENT}/lock"
TF_HTTP_LOCK_METHOD="POST"

# The state-unlocking endpoint for the environment
TF_HTTP_UNLOCK_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_ENVIRONMENT}/lock"
TF_HTTP_UNLOCK_METHOD="DELETE"
```

The username and password (or token) that are used to authenticate with GitLab to manage
the Terraform state are set using the `TF_HTTP_USERNAME` and `TF_HTTP_PASSWORD` environment
variables respectively.

If you are [using GitLab CI/CD to automate deployments](../deployment/automation.md#gitlab-cicd),
then the pipeline will be issued with a suitable token. The
[sample configuration](https://github.com/stackhpc/azimuth-config/blob/main/.gitlab-ci.yml.sample)
includes configuration to populate these variables using this token.

If you are not using automation but your GitLab installation has
[project access tokens](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html)
available, you can configure a project access token and store it (encrypted!) in the
`env.secret` file, referencing the bot username:

```sh  title="env.secret"
TF_HTTP_USERNAME="project_<id>_bot"
TF_HTTP_PASSWORD="<project access token>"
```

If you need to access an environment deployed using automation, or you do not have project
access tokens available, then you can use a
[Personal access token](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html),
which at least avoids using your password.

!!! danger  "Never commit personal access tokens"

    You should **never** commit a personal access token to the configuration repository,
    even encrypted, because it is not possible to set a project scope.

If using a personal access token, you should export the relevant variables before activating
an environment:

```sh
# Export directly
export TF_HTTP_USERNAME="<username>"
export TF_HTTP_PASSWORD="<token>"

# Export from a file that has been added to .gitignore
export $(cat env.gitlab-creds | xargs)

source ./bin/activate my-site
```

### S3

If you are using an S3-API-compatible object store, such as [Ceph Object Gateway](https://docs.ceph.com/en/latest/radosgw/index.html), to host your configuration repository, you can use the
[Terraform S3 backend](https://www.terraform.io/language/settings/backends/s3)
to facilitate the remote storage of the Terraform state for your environments. 

!!! tip

    Depending on the provider of your S3-API-compatible object store, the specific configuration options and
    their values required in the following section may differ. The configuration provided below is for Ceph Object Gateway.

!!! warning
    All configuration options described in the Terraform S3 backend [documentation](https://www.terraform.io/language/settings/backends/s3) should
    be specified as environment variables with the prefix `AZIMUTH_TERRAFORM_BACKEND_S3_`.

All non-secret configuration options can be specified in the `env` file of your environment.
 
```sh  title="env"
# Use the s3 backend type [note lowercase "s"]
AZIMUTH_TERRAFORM_BACKEND_TYPE=s3

# An *existing* bucket to store state in
AZIMUTH_TERRAFORM_BACKEND_S3_BUCKET=azimuth-terraform-state

# State "key" or filename
AZIMUTH_TERRAFORM_BACKEND_S3_KEY=azimuth.tfstate

# This must be specified for all S3 backends, but its value is often
# arbitrary when using Ceph Object Gateway
AZIMUTH_TERRAFORM_BACKEND_S3_REGION=notused-but-required-for-s3-backed

# S3 endpoint (no "http(s)://" required)
AZIMUTH_TERRAFORM_BACKEND_S3_ENDPOINT=example.com

# Skip credentials validation via the STS API as this doesn't exist for
# Ceph Object Gateway
AZIMUTH_TERRAFORM_BACKEND_S3_SKIP_CREDENTIALS_VALIDATION="true"

# Force path-style S3 URLs (https://<HOST>/<BUCKET> instead of 
# https://<BUCKET>.<HOST>).
AZIMUTH_TERRAFORM_BACKEND_S3_FORCE_PATH_STYLE="true"

# Skip validation of provided region name.
AZIMUTH_TERRAFORM_BACKEND_S3_SKIP_REGION_VALIDATION="true"
```

Then specify your S3 credentials in the `env.secret` file in your environment. By [default](secrets.md), this file is encrypted by `git-crypt`.

```sh  title="env.secret"
AWS_ACCESS_KEY_ID=<secret_key>
AWS_SECRET_ACCESS_KEY=<access_key>
```

Finally, add a new vars file to your environment's Ansible inventory to allow Ansible to read the values of the non-secret
environment variables:

!!! warning
    It is not required to specify `AWS_ACCESS_KEY_ID` or `AWS_SECRET_ACCESS_KEY` here!

```yaml title="environments/your_en/inventory/group_vars/all/terraform_state.yml"
---

terraform_backend_type: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_TYPE') }}"

terraform_backend_config:
  bucket: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_S3_BUCKET') }}"
  region: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_S3_REGION') }}"
  key: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_S3_KEY') }}"
  endpoint: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_S3_ENDPOINT') }}"
  skip_credentials_validation: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_S3_SKIP_CREDENTIALS_VALIDATION') }}"
  force_path_style: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_S3_FORCE_PATH_STYLE') }}"
  skip_region_validation: "{{ lookup('ansible.builtin.env', 'AZIMUTH_TERRAFORM_BACKEND_S3_SKIP_REGION_VALIDATION') }}"
```
